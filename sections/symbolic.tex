% !TEX root=../main.tex

\section{Symbolic execution of TopHat}
\label{sec:symbolic}

A symbolic execution semantics aims to execute a program without knowing its input.
Instead, symbols are fed into the program, and path conditions are recorded.

Consider the tiny example below.
\begin{TASK}
  \ <<x,y>>. if x > y then <<y, x>> else <<x, y>>
\end{TASK}

This program takes two values and returns a pair, where the second element is larger than the first.
When we run this program symbolically, we have to enter two symbols for $x$ and $y$, say $s_0$ and $s_1$ respectively.
There are two possible outcomes, namely
$\tuple{s_1,s_0}$, provided that $s_0 < s_1$, or
$\tuple{s_0,s_1}$, provided that $s_0 \geq s_1$.

Now, the property that we want to prove for this program is that no matter what the input is, the second element should always be larger than the first, which we write as $\psi(a,b)= b \geq a$.
Looking at the two symbolic runs, we can immediately conclude that this property.
Of course this is a trivial example, one can conclude or even prove that the property holds without symbolic execution.
But when applying this technique to larger programs, it is a powerful tool to show that a program behaves as expected.
\cref{sec:examples} illustrates this by applying symbolic execution to a larger example.


\subsection{Symbolic TopHat}

For symbolic \TOPHAT, we extend the task language, states and input with symbols.
The semantics mentioned in \cref{sec:tophat} also need to be extended to support symbols.
The same holds for the observation functions.

\todo{Say something about inclusion:
  $t\subset \tilde{t}$
  $\sigma \subset \tilde{\sigma}$
  $i\subset \tilde{\imath}$
}

\begin{definition}[Simulation]
  \todo{Improve definition.}
  $t,\sigma\drive{}^* \overline{\tilde{v},\tilde{I},\tilde{\Phi}}$
\begin{align*}
  t,\sigma             & \drive{} & \overline{\tilde{t}_1,\tilde{\sigma}_1,\tilde{\imath}_1,\phi_1}\\
  \tilde{t}_1,\tilde{\sigma}_1         & \drive{} & \overline{\tilde{t}_2,\tilde{\sigma}_2,\tilde{\imath}_2,\phi_2}\\
                       & \vdots   & \\
  \tilde{t}_{n-1},\tilde{\sigma}_{n-1} & \drive{} & \overline{\tilde{t}_n,\tilde{\sigma}_n,\tilde{\imath}_n,\phi_n}
\end{align*}
With $\Value(\tilde{t}_n,\tilde{\sigma}_n)=\tilde{v}$\\
$\Value(\tilde{t}_{i<n},\tilde{\sigma}_{i<n})=\bot$\\
$\tilde{I}=\tilde{\imath}_1,\cdots,\tilde{\imath}_n$\\
$\Phi = \phi_1\land\cdots\land\phi_n$\\
$\Sat(\Phi)$
\end{definition}

\todo{Tell that this is a DIFFERENT simulation definition than what is used in the previous paper.}

\begin{figure}[ht]
  \small
  \usemacro{G-SExpressions-Compact}
  \caption{Syntax of expressions in Symbolic \TOPHAT.}
  \label{fig:syntaxexprsymtophat}
\end{figure}

\begin{figure}[ht]
  \small
  \usemacro{G-SValues-Compact}
  \usemacro{G-STasks-Compact}
  \caption{Syntax of values in Symbolic \TOPHAT.}
  \label{fig:syntaxvalues}
\end{figure}
