% !TEX root=../main.tex

\section{Generating hints for TopHat}
\label{sec:assistive}
The section introduces our \ASTOPHAT system.
%What do we wanna do?
The goal of \ASTOPHAT is to provide next step hints, that brings users closer to their goal.
During the execution of a \TOPHAT program, users are presented with input fields, choices and continue buttons.
The way in which the task progresses and the resulting task value depends on their input.
For any point in the execution, we want to present the user with all options that are on the path to the goal that they have selected.
These options are either concrete steps, like continue, pick the left task or pick the right task,
or a value to be entered into an editor.
Since the concrete value also influences the flow of the program, these values can come with restrictions.
For example, enter an integer, but this integer must be larger than zero.

\subsection{Symbolic execution of TopHat}
\label{sec:symbolic}

Our goal is to provide end users with next step hints in such a way that, whey they follow up those hints, they will reach a specified goal.
To check if this goal is achievable, we make use of symbolic execution.
A symbolic execution semantics~\cite{King1975,Boyer1975} aims to execute a program without knowing its input.
Instead, symbols are fed into the program.
During evaluation, symbolic execution records path conditions.
The symbolic results together with the path conditions can be used to prove properties of the program.

\begin{TASK}[
    float=ht,
    % numbers=right,
    caption={Ordering of tuple elements.},
    captionpos=b,
    label=lst:ordering]
  enter Int <&> enter Int >>= \<<x,y>>. if x > y then edit <<y, x>> else edit <<x, y>>
\end{TASK}

Consider the tiny example in \cref{lst:ordering}.
This program asks for two integer values.
After users entered this information, the step makes sure the result will be an editor containing a pair,
where the second element is larger then the first.
When we run this program symbolically, we have to create fresh symbols for both editors, say $s_0$ and $s_1$ respectively.
Continuing normalisation, there are two possible outcomes, namely
\begin{itemize}
  \item $\tuple{s_1,s_0}$, provided that the path condition $\phi = s_0 > s_1 = s_1 < s_0$ holds; or
  \item $\tuple{s_0,s_1}$, with path condition $\phi = \lnot (s_0 > s_1) = s_0 \leq s_1$.
\end{itemize}

Now, the property that we want to prove for this program is that no matter what the input is, the second element should always be larger than the first,
which we write as $\psi(\<a, b\>)= a \leq b$.
Looking at the two symbolic runs, we can immediately conclude that this property holds.
\todo{Goal of next sentences? â€“TS}
Of course this is a trivial example, one can conclude or even prove that the property holds without symbolic execution.
But when applying this technique to larger programs, it is a powerful tool to show that a program behaves as expected.
\cref{sec:assistivedining,sec:assistivetax} illustrates this by applying symbolic execution to larger examples.

\todo{Describe pruning of branches which do not satisfy and introduce $\Sat$.}


\subsection{Symbolic semantics for TopHat}

To support symbolic execution in \TOPHAT, we extend our language with symbols.
We denote entities containing symbols with an additional tilde,
so $\tilde{t}$, $\tilde{\sigma}$, and $\tilde{\i}$ are respectively tasks, states, and inputs containing symbols.
% The semantics mentioned in \cref{sub:semantics} needs to be extended to support symbols.
In the symbolic world, the arrows presented in \cref{sub:semantics} have a squiggly symbolic counterpart.

\begin{table}
  \caption{}
  \label{}
  \centering
  \begin{tabular}{l@{\Quad}L@{\Quad}L}
    \toprule
                  & \text{Concrete} & \text{Symbolic} \\
    \midrule
    Expressions   & e               & \tilde{e} \\
    Tasks         & t               & \tilde{t} \\
    States        & \sigma          & \tilde{\sigma} \\
    Inputs        & i               & \tilde{\imath} \\
    \midrule
    Evaluation    & \RelationE      & \RelationSE \\
    Normalisation & \RelationN      & \RelationSN \\
    Striding      & \RelationS      & \RelationSS \\
    Interacting   & \RelationI      & \RelationSI \\
    Handling      & \RelationH      & \RelationSH \\
    \bottomrule
  \end{tabular}
\end{table}


The same holds for the observation functions.
The simulation that drives the symbolic execution an now be defined as follows.

\todo{Say something about inclusions:
  $t\subset \tilde{t}$,
  $\sigma \subset \tilde{\sigma}$,
  $i\subset \tilde{\imath}$
}

\begin{definition}[Simulation]
  $t,\sigma\simulate \overline{\tilde{v},\tilde{I},\Phi}$ where

  \begin{minipage}[c]{0.4\textwidth}
    \begin{align*}
      t,\sigma             & \siminteract  \overline{\tilde{t}_1,\tilde{\sigma}_1,\tilde{\imath}_1,\phi_1}\\
      \tilde{t}_1,\tilde{\sigma}_1         & \siminteract  \overline{\tilde{t}_2,\tilde{\sigma}_2,\tilde{\imath}_2,\phi_2}\\
                           & \hspace{2mm}\vdots    \\
      \tilde{t}_{n-1},\tilde{\sigma}_{n-1} & \siminteract{}  \overline{\tilde{t}_n,\tilde{\sigma}_n,\tilde{\imath}_n,\phi_n}
    \end{align*}
\end{minipage}
\begin{minipage}[c]{0.1\textwidth}
  \Quad
\end{minipage}
\begin{minipage}[c]{0.3\textwidth}
  \begin{align*}
    \text{With }& \Value(\tilde{t}_n,\tilde{\sigma}_n)=\tilde{v}\\
    &\Value(\tilde{t}_{i<n},\tilde{\sigma}_{i<n})=\bot\\
    &\tilde{I}=\tilde{\imath}_1,\cdots,\tilde{\imath}_n\\
    &\Phi = \phi_1\land\cdots\land\phi_n\\
    &\Sat(\Phi)
  \end{align*}
\end{minipage}
\end{definition}

Here, $t$ is the task program to be symbolically executed, under state $\sigma$,
resulting in a set of tuples containing the resulting symbolic value $\tilde{v}$, a list of symbolic inputs $\tilde{I}$ and a path condition $\Phi$ for that specific execution.

Only viable executions are permitted, this is enforced by validating the satisfiability of the path condition, denoted as $\Sat(\Phi)$.

The simulation definition used in this paper differs from the one in previous work~\cite{Naus2019}.
Previously, infinite symbolic executions were filtered out by allowing two steps look-ahead in case of idempotent executions.
The definition above only allows finite executions by definition.

\todo{use vending machine example to illustrate symbolic tophat (?)}



\subsection{}

%How do we do this?

In order to calculate next step hints, first a goal must be formulated.
Since we are concerned with the resulting task value, the goal must be a predicate over the resulting value.
A task $\tilde{t}$ is considered done, as soon as it has an observable value $\tilde{v}$.

\begin{figure}
  \usemacro{O-Hints}
  \caption{Definition of next step hint function.}
  \label{fig:hints}
\end{figure}


Hints are calculated by means of the $\Hints$ function listed in \cref{fig:hints}.
As input it receives the task $t$ and state $\sigma$, together with the goal predicate $g$.
First, the simulate function is called on the task and input.
We only want to use the symbolic executions that satisfy the goal condition.
Executions that satisfy the goal $g(\tilde{v})$ are selected.
Since $\tilde{v}$ could contain symbols, it might be the case that $g(\tilde{v})$ is symbolic.
Therefore, we also require that the conjunction with the path condition $\Phi$ is satisfiable ($\Sat(\Phi\land g(\tilde{v}))$).

From the executions that fulfil this requirement, we return the first symbolic input $\tilde{i}$ from the complete list of inputs $\tilde{i}::\tilde{I}$,
together with the full condition that must hold ($\Sat(\Phi\land g(\tilde{v}))$).
The resulting set contains pairs of symbolic input guarded by a condition.

\cref{sec:assistivetax} demonstrates on the basis of the tax example listed in \cref{sec:tax} how the results of the symbolic execution are used to construct automatic next step hints.
\cref{sec:assistivedining} shows how hints can be generated during the execution of the example \TOPHAT program listed in \cref{sec:dining}.
Then in \cref{sec:implementation}, our implementation of \ASTOPHAT is presented.


\subsection{Tax subsidy request}
\label{sec:assistivetax}

%recall
\cref{sec:tax} lists an example program in \TOPHAT for applying for a solar panel tax refund.
The user enters the invoice date and invoice amount, the installation company confirms, and finally the tax officer either approves or denies the request.

In this section, we will demonstrate what symbolic execution looks like for this example, and how we generate next step hints from the symbolic execution results.
First, we call the simulate function $\simulate$ on the program, with an empty state.
The resulting set of symbolic executions is listed in \cref{table:tax}.

\begin{table}[ht]
  \centering
  \begin{tabular}{LLL}
    \toprule
    \text{Symbolic value} & \text{Symbolic input} & \text{Path condition} \\
    \midrule
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second \First, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second \First, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\Second \First, \First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\Second \First, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \Second \First, \First \First s_{\id{a}}, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \Second \First, \First \Second s_{\id{i}}, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \midrule
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second \First, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second \First, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\Second \First, \First \First s_{\id{a}}, \First \Second s_{\id{i}}, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\Second \First, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \Second \First, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \Second \First, \First \Second s_{\id{i}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\Second \Second,\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\Second, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \Second, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \Second, \First \Second s_{\id{i}}, \First]  & \True \\
    \bottomrule
  \end{tabular}
  \caption{The results of running the simulate function on the program from \cref{lst:tax}.}
  \label{table:tax}
\end{table}

Each line represents one symbolic execution.
In the first column, the resulting symbolic value $\tilde{v}$ is listed.
The second column lists the symbolic input $\tilde{I}$ that was produced to arrive at that value, followed by the path condition $\Phi$.
The symbolic values that are produced are $s_i$ for the invoice date and $s_a$ for the invoice amount.

The definition of $\Hints$ describes how these results should be used in order to calculate next step hints.
First of all, we need a goal $g$ to select the symbolic runs that we are interested in.
The most straight forward goal would be that we want to end up in a situation where we get a subsidy amount larger than zero.
This goal can be formulated as $\lambda \tuple{v,\_,\_,\_,\_}\rightarrow v>0$.

The first six symbolic runs listed in \cref{table:tax} fulfil the goal condition.
From those runs, we then take the first symbolic input, together with the path condition, in conjunction with the path condition applied to the goal.

After removing duplicates and redundant information, the result of $\Hints$ is as follows.

\begin{align*}
  \tuple{&\First \First s_{\id{a}},  &&(\min\ 600\ (s_{\id{a}}/10)) > 0} &\\
  \tuple{&\First \Second s_{\id{i}}, &&(\Today-s_{\id{i}}) < \OneYear} &\\
  \tuple{&\Second \First,            &&\True} &
\end{align*}


\todo{write conclusion}

\subsection{Dining Computer Scientists}
\label{sec:assistivedining}

%recall
Recall the example program Dining Computer Scientists from \cref{sec:dining}.
Three computer scientist sit at a table and have to coordinate in order to eat their meals.

%what hints do we want to give?
We want to calculate all possible next steps that lead to the goal.
The goal in this example is for all computer scientists to finish their meal.

%write the goal
In terms of the resulting task value, this means that we want to arrive at the value "Full bellies".
Witten as a predicate, we get $g=\lambda v\rightarrow v = "\text{Full bellies}"$.

%what does the result of H look like?
Let us assume that both Grace Hopper and Ada Lovelace have already picked up the forks to their left (fork1 and fork2 respectively).
We then find ourselves in the following situation.


\begin{figure}
  \centering
\begin{minipage}[r]{0.55\textwidth}

  \begin{align*}
  t =\ &\text{scientist} "\text{Alan Turing}" \text{fork0}\ \text{fork1} \And\\
      &\unit \Next \lambda \unit .\\
      &\Quad \If{!\text{fork2}}{\text{fork1} := \True}{\Fail} \And\\
      &\unit \Next \lambda \unit .\\
      &\Quad \If{!\text{fork0}}{\text{fork2} := \True}{\Fail} Then \lambda \_.\\
      &\Quad \Edit "\text{Full bellies}"\\
  \sigma =\ &\{\text{fork0}\mapsto \True, \text{fork1}\mapsto \False,\text{fork2}\mapsto \False\}
  \end{align*}

\end{minipage}
\begin{minipage}[r]{0.05\textwidth}
  \
\end{minipage}
\begin{minipage}[r]{0.3\textwidth}
\tikzset{every picture/.style={line width=0.75pt}} %set default line width to 0.75pt

  \begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-0.5,xscale=0.5]
  %uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

  %Shape: Circle [id:dp8519268538531043]
  \draw   (229,147.5) .. controls (229,90.89) and (274.89,45) .. (331.5,45) .. controls (388.11,45) and (434,90.89) .. (434,147.5) .. controls (434,204.11) and (388.11,250) .. (331.5,250) .. controls (274.89,250) and (229,204.11) .. (229,147.5) -- cycle ;
  %Shape: Circle [id:dp8204933417548707]
  \draw   (305,84) .. controls (305,70.19) and (316.19,59) .. (330,59) .. controls (343.81,59) and (355,70.19) .. (355,84) .. controls (355,97.81) and (343.81,109) .. (330,109) .. controls (316.19,109) and (305,97.81) .. (305,84) -- cycle ;
  %Shape: Circle [id:dp7478076126793654]
  \draw   (360,180) .. controls (360,166.19) and (371.19,155) .. (385,155) .. controls (398.81,155) and (410,166.19) .. (410,180) .. controls (410,193.81) and (398.81,205) .. (385,205) .. controls (371.19,205) and (360,193.81) .. (360,180) -- cycle ;
  %Shape: Circle [id:dp3120260710082954]
  \draw   (253,183) .. controls (253,169.19) and (264.19,158) .. (278,158) .. controls (291.81,158) and (303,169.19) .. (303,183) .. controls (303,196.81) and (291.81,208) .. (278,208) .. controls (264.19,208) and (253,196.81) .. (253,183) -- cycle ;
  %Straight Lines [id:da6820891014633774]
  \draw    (331,190) -- (331,236) ;


  %Curve Lines [id:da1548185264621137]
  \draw    (323.5,190) .. controls (324.5,210) and (336.5,210) .. (337.5,190) ;



  %Straight Lines [id:da4306446303925887]
  \draw    (294.3,133.27) -- (256.15,107.56) ;


  %Curve Lines [id:da9253738091345234]
  \draw    (298.49,127.05) .. controls (281.34,116.7) and (274.64,126.65) .. (290.66,138.66) ;



  %Straight Lines [id:da7927760692654279]
  \draw    (362.12,130.68) -- (402.39,108.44) ;


  %Curve Lines [id:da6105283277592903]
  \draw    (365.75,137.25) .. controls (382.77,126.7) and (376.97,116.2) .. (358.98,124.99) ;




  % Text Node
  \draw (252,242) node  [align=left] {Alan};
  % Text Node
  \draw (330,24) node  [align=left] {Grace};
  % Text Node
  \draw (416,243) node  [align=left] {Ada};


  \end{tikzpicture}

\end{minipage}\\
\caption{Task, state and visual representation after two interactions}
\end{figure}
\fixme{REPLACE THIS IMAGE!}





Calling $\Hints(t,\sigma,g)$ will result in just one hint, namely $\tuple{\Second\Second\Continue,\True}$.

This means that the only step towards the goal $g$ is for Ada Lovelace to pick up the right fork.
Although it is also possible for Alan Turing to pick up the fork to his left, this step is not a valid hint.
Performing this action will result in deadlock.


\subsection{Implementation}
\label{sec:implementation}

%we have an implementation
We added \ASTOPHAT to our existing implementation of symbolic \TOPHAT in Haskell.\footnote{https://github.com/timjs/symbolic-tophat-haskell}
%it works like this
We have defined the hints function in exactly the same way as in \cref{fig:hints}.
It directly leverages the existing symbolic execution, which makes use the z3 smt solver.

%our examples work in implementation
The examples from \cref{sec:examples} have been tested in the implementation.
