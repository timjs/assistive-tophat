% !TEX root=../main.tex

\section{Properties}
\label{sec:properties}

We define an evaluation function that takes a task, state and list of inputs,
and returns the value of the task after application of all inputs.
This is a partial function since not all tasks have an observable value.

All elements of firsts are valid hints.

\begin{definition}[Evaluate]
  $t,\sigma\drive{I}^* v$
  \begin{align*}
    t,\sigma             & \drive{i_1} & t_1,\sigma_1\\
    t_1,\sigma_1         & \drive{i_2} & t_2,\sigma_2\\
                         & \vdots   & \\
    t_{n-1},\sigma_{n-1} & \drive{i_n} & t_n,\sigma_n
  \end{align*}
  With $\Value(t_n,\sigma_n)=v$\\
  $\Value(t_{i<n},\sigma_{i<n})=\bot$\\
  $I=i_1,\cdots,i_n$
\end{definition}

\subsection{Correctness of firsts}

The most important property we would like to prove, is the correctness of the hints calculated by firsts.
Intuitively, for a set of next step hints to be correct, they should be
- valid steps a user can actually take
- bring the user closer to the desired goal
- contain ALL steps that bring the user closer to their goal.

We separate this property into two parts.


\begin{lemma}[Soundness of firsts]
  \label{lem:soundfirsts}

For all tasks $t$, states $\sigma$ and goals $g$,
for every next step hint $(\tilde{i},\Phi)$ in $\Hints(t,\sigma,g)$,
there exists a sequence of inputs $I$ and input $i$ such that $\tilde{i}\sim i$,
$\Sat([s\mapsto c]\Phi)$, $t,\sigma\drive{i} t',\sigma'\drive{I}^* v$ and $gv$.
\end{lemma}

\begin{proof}
  \cref{lem:soundfirsts} follows from the premise of \refrule{R-Hints} and \cref{lem:soundsimulate} as follows.

  The premise of \refrule{R-Hints} gives us that for every pair $\tilde{i},\Phi)$ produced by $\Hints$,
  there exists a pair $(\tilde{v},\tilde{i}:\tilde{is},\Phi)$ with $\Sat(\Phi\land g \tilde{v})$.
  Then by \cref{lem:soundsimulate} we have that there exists a sequence of concrete inputs $I$ such that
  $t,\sigma\drive{I}^*v$ and $g v$.
\end{proof}

\begin{lemma}[Completeness of firsts]
  \label{lem:completefirsts}
  For all tasks $t$, states $\sigma$, lists of input $(i:is)$ and goals $g$,
  if $t,\sigma,\drive{i:is}^*v$ and $g v$, then there exists a symbolic input $\tilde{i}$ and path condition $\Phi$
  such that $(\tilde{i},\Phi)\in\Hints(t,\sigma)$ with $\tilde{i}\sim i$ and $\Sat([s\mapsto c]\Phi)$ with $c\in i$ and $s\in i$.
\end{lemma}

\begin{proof}
  In order to prove that $i$ is contained in $\Hints(t,\sigma)$, we need to show that the premise of \refrule{R-Hints} holds.

  This means showing that $(\tilde{v},\tilde{i}:\tilde{is},\Phi)\in t,\sigma\drive{}^*$, with $\tilde{i}\sim i$ and $\Sat([s_0\mapsto c_0,\cdots,s_n\mapsto c_n]\land g\tilde{v})$, where $[c_0,\cdots,c_n]\in i:is$ and $[s_0,\cdots,s_n]\in \tilde{i}:\tilde{is}$.

  By \cref{lem:completesimulate}, we directly obtain that this indeed exists. Therefore we know that $\tilde{i}$ and $\Phi$ exist.
\end{proof}


Since the $\Hints$ function relies on the $\Simulate$ function, we can make use of soundness and completeness of that function with respect to $\Evaluate$, when proving the lemma's above.

\begin{lemma}[Soundness of simulate]
  \label{lem:soundsimulate}
  For all tasks $t$ and states $\sigma$
  such that $t,\sigma\drive{}^*\overline{\tilde{v},\tilde{I},\Phi}$
  then for all results $(\tilde{v},\tilde{I}=[\tilde{i}_0,\cdots,\tilde{i}_n],\Phi)$
  there exists a concrete input $I$ with the same length as the symbolic input $\tilde{I}$
  such that $t,\sigma\drive{I}^*v$
  with $[s_i\mapsto c_i]\tilde{v}=v$ and $[s_i\mapsto c_i]\Phi$
  where $s_i\in\tilde{i_i}$ and $c_i\in i_i$.
\end{lemma}

\begin{proof}[Soundness of simulate]
  The structure of this proof is outlined in \cref{fig:proofstructure}.

  We have $t$ and $\sigma$ such that $t,\sigma\drive{}^*\overline{\tilde{v},\tilde{I},\Phi}$.
  By definition of simulation $(\drive{}^*)$, we know that for each tuple $(\tilde{v},\tilde{I},\Phi)$,
  the following sequence of symbolic drive steps has occurred.
  \begin{align*}
      t,\sigma\drive{}&\tilde{t}_1,\tilde{\sigma}_1,\tilde{i}_1,\phi_1&\\
                      &\tilde{t}_1,\tilde{\sigma}_1\drive{}&\tilde{t}_2,\tilde{\sigma}_2,\tilde{i}_2,\phi_2\\
                      &                                    &\tilde{t}_2,\tilde{\sigma}_2\drive{}&\cdots&\\
                      &                                    &                                    &\cdots&
                      \drive{}\tilde{t}_n,\tilde{\sigma}_n,\tilde{i}_n,\phi_n
  \end{align*}

  with $\Value(\tilde{t}_n,\tilde{\sigma}_n)=\tilde{v}$ and $\Sat(\phi_1\land\cdots\land\phi_n)$.

  We need to show that there exits an $I$ such that $t,\sigma\drive{I}^*v$, which is defined similarly as follows.

  $t,\sigma\drive{i_1}t_1,\sigma_1\drive{i_2}t_2,\sigma_2\drive{i_3}\cdots \drive{i_n}t_n,\sigma_n$ with $\Value(t_n,\sigma_n)$.

  By \cref{lem:sounddriving}, we know that $t,\sigma\drive{i_1}t_1,\sigma_1$ exists, since $t,\sigma\Consistent_{\emptyset}t,\sigma,\True$.
  This also gives us that $\tilde{i_1}\sim i_1$, and $t_1,\sigma_1\Consistent_{[s_1\mapsto c_1]}\tilde{t}_1,\tilde{\sigma}_1,\phi_1$ with $s_1\in\tilde{i}_1$ and $c_1\in i_1$.

  By repeatedly applying \cref{lem:sounddriving}, until we arrive at $\tilde{t}_n,\sigma{t}_n$,
  we can show that there indeed exists an $I$ such that $t,\sigma\drive{I}^*v$ with $[s_1\mapsto c_1,\cdots,s_n\mapsto c_n]\tilde{v}=v$
  and $[s_1\mapsto c_1,\cdots,s_n\mapsto c_n]\Phi$, namely $I=[i_1,\cdots,i_n]$.

\end{proof}

\begin{lemma}[Completeness of simulate]
  \label{lem:completesimulate}
  For all tasks $t$, states $\sigma$ and lists of input $I$
  such that $t,\sigma\drive{I}^*v$
  there exists a symbolic value $\tilde{v}$ and a symbolic input $\tilde{I}$ with the same length as $I$,
  such that $(\tilde{v},\tilde{I},\Phi)\in t,\sigma\drive{}^*$,
  with $\tilde{i_i}\sim i_i$, $[s_i\mapsto c_i]\tilde{v}=v$ and $[s_i\mapsto c_i]\Phi$,
  where $s_i\in\tilde{i_i}$ and $c_i\in i_i$.
\end{lemma}

\begin{proof}[Completeness of simulate]
  The structure of this proof is outlined in \cref{fig:proofstructure}.

  We have $t$ and $\sigma$ such that $t,\sigma\drive{I}^*v$.
  By definition of $\drive{I}^*$, we have the following.

  $t,\sigma\drive{i_1}t_1,\sigma_1\drive{i_2}\cdots \drive{i_n}t_n,\sigma_n$ with $\Value(t_n,\sigma_n)$ and $I=[i_1,\cdots,i_n]$.

  We need to show that we have $(\tilde{v},\tilde{I},\Phi)\in t,\sigma\drive{}^*)$,
  which is defined as follows.

  \begin{align*}
      t,\sigma\drive{}&\tilde{t}_1,\tilde{\sigma}_1,\tilde{i}_1,\phi_1&\\
                      &\tilde{t}_1,\tilde{\sigma}_1\drive{}&\tilde{t}_2,\tilde{\sigma}_2,\tilde{i}_2,\phi_2\\
                      &                                    &\tilde{t}_2,\tilde{\sigma}_2\drive{}&\cdots&\\
                      &                                    &                                    &\cdots&
                      \drive{}\tilde{t}_n,\tilde{\sigma}_n,\tilde{i}_n,\phi_n
  \end{align*}

  with $\Value(\tilde{t}_n,\tilde{\sigma}_n)=\tilde{v}$ and $\Sat(\phi_1\land\cdots\land\phi_n)$.

  By \cref{lem:completedriving}, we know that $t,\sigma\drive{}\tilde{t}_1,\tilde{\sigma}_1,\tilde{i}_1,\phi_1$ exists,
  since $t,\sigma,t\Consistent_{\emptyset}\sigma,\True$.
  This also gives us that $\tilde{i}_1\sim i_1$ and $t_1,\sigma_1\Consistent_{[s_1\mapsto c_1]}\tilde{t}_1,\tilde{\sigma}_1,\phi_1$ with $s_1\in\tilde{i}_1$ and $c_1\in i_1$.

  By repeated application of \cref{lem:completedriving}, untill we arrive at $t_n,\sigma_n$,
  we can show that there exists a $\tilde{I}$ such that $t,\sigma\drive{}^*\tilde{t}_n,\tilde{\sigma}_n,\tilde{I},\Phi$,
  namely $[\tilde{i}_1,\cdots,\tilde{i}_n]$.

\end{proof}

$\Evaluate$ and $\Simulate$ make use of the driving and symbolic driving semantics respectively, so we again first prove those sound and complete with respect to each other.


\begin{definition}[Consistence relation $\Consistent$]
A concrete task $t$ and concrete state $\sigma$
are considered to be consistent with a symbolic task $\tilde{t}$, symbolic state $\tilde{\sigma}$ and path condition $\Phi$
under a certain mapping $M=[s_1\mapsto c_1,\cdots,s_n,\mapsto c_n]$, denoted as $t,\sigma \Consistent_M \tilde{t},\tilde{\sigma},\Phi$
if and only if $M\tilde{t}=t$, $M\tilde{\sigma}=\sigma$ and $M\Phi$
\end{definition}

\begin{lemma}[Soundness of driving]
  \label{lem:sounddriving}
  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $t,\sigma\Consistent_M\tilde{t},\tilde{\sigma},\Phi$ implies
  that for all pairs $(\tilde{t}',\tilde{\sigma}',\tilde{i},\phi)$ in $\tilde{t},\tilde{\sigma}\drive{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi}$,
  $\Sat(\Phi\land\phi)$ implies that there exists an input $i$ such that $\tilde{i}\sim i$,  $t,\sigma\drive{i}t',\sigma'$ and $t',\sigma' \Consistent_{M.[s\mapsto c]} \tilde{t}',\tilde{\sigma}',\Phi\land\phi$ where where $s\in\tilde{i}$ and $c\in i$.
\end{lemma}

\begin{proof}[Soundness of driving]
  The symbolic driving semantics consists of only one rule, \refrule{SI-Handle}.
  Given that $t,\sigma\Consistent_M\tilde{t},\tilde{\sigma},\Phi$ and $\tilde{t},\tilde{\sigma}\drive{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi_1}$,
  \cref{lem:soundhandle} gives us that for each pair $(\tilde{t}',\tilde{\sigma}',\tilde{i},\phi_1)$
  there exists an input $i$ such that $\tilde{i}\sim i$, $t,\sigma\handle{i}t',\sigma'$
  and $t',\sigma'\Consistent_{M.[s\mapsto c]}\tilde{t'},\tilde{\sigma'},\Phi\land\phi_1$.

  Then, by \cref{lem:soundnorm}, given that $\tilde{t'},\tilde{\sigma'}\normalise\overline{\tilde{t''},\tilde{\sigma''}',\phi_2}$,
  we obtain that for each pair $(\tilde{t''},\tilde{\sigma''}',\phi_2)$, we have that $\Sat(\Phi\land\phi_1\land\phi_2)$ implies
  that $t',\sigma'\hat{\normalise}t'',\sigma''$ with $t'',\sigma''\Consistent_{M.[s\mapsto c]}\tilde{t''},\tilde{\sigma''},\Phi\land\phi_1\land\phi_2$.
\end{proof}



\begin{lemma}[Completeness of driving]
  \label{lem:completedriving}
  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $t,\sigma\Consistent_{M}\tilde{t},\tilde{\sigma},\Phi$ implies
  that for all inputs $i$ such that $t,\sigma\drive{i}t',\sigma'$,
  there exists a symbolic input $\tilde{i}$, $\tilde{i}\sim i$ such that
  $\tilde{t},\tilde{\sigma}\drive{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi}$, $\Sat(\Phi\land\phi)$ and $t',\sigma'\Consistent_{M.[s\mapsto c]}\tilde{t}',\tilde{\sigma}',\Phi\land\phi$ where where $s\in\tilde{i}$ and $c\in i$.
\end{lemma}

Where $\tilde{i}\sim i$ is defined as follows.

\begin{definition}[Input simulation]
  A symbolic input $\tilde{i}$ simulates a concrete input $i$ denoted as $\tilde{i}\sim i$ in the following cases.\\
  $s\sim a$, where $s$ is a symbol and $a$ a concrete action.\\
  $\tilde{i}\sim i\implies \First \tilde{i} \sim \First i$\\
  $\tilde{i}\sim i\implies \Second \tilde{i} \sim \Second i$
\end{definition}

And $s\in \tilde{i}$ and $c\in i$ are defined as follows.

\begin{definition}[Value from input]
  $c\in \First i = c\in i $\\
  $c\in \Second i = c\in i $\\
  $c\in a = a $
\end{definition}

\begin{definition}[Symbol from input]
  $s\in \First \tilde{i} = s\in \tilde{i} $\\
  $s\in \Second \tilde{i} = s\in \tilde{i} $\\
  $s\in a = a $
\end{definition}

Since the driving semantics depends on the handling and normalisation semantics, we need to show that they too are sound and complete, before we can prove the lemma's above.


\begin{lemma}[Soundness of handling]
  \label{lem:soundhandle}

  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $t,\sigma\Consistent_{M}\tilde{t},\tilde{\sigma},\Phi$ implies
  that for all symbolic inputs $\tilde{i}$ such that $\tilde{t},\tilde{\sigma}\handle{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi}$ and
  for all pairs $(\tilde{t}',\tilde{\sigma}',\tilde{i},\phi)$,
  $\Sat(\Phi\land\phi)$ implies that there exists an input $i$ such that $\tilde{i}\sim i$,  $t,\sigma\handle{i}t',\sigma'$ and $t',\sigma'\Consistent_{M.[s\mapsto c]}\tilde{t}',\tilde{\sigma}',\Phi\land\phi$ where where $s\in\tilde{i}$ and $c\in i$.

\end{lemma}



\begin{lemma}[Soundness of normalisation]
  \label{lem:soundnorm}
  For all concrete expressions $e$, concrete states $\sigma$, symbolic expressions $\tilde{e}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $e,\sigma\Consistent_{M}\tilde{e},\tilde{\sigma},\Phi$ implies
  that if $\tilde{e},\tilde{\sigma}\tilde{\normalise}\overline{\tilde{t},\tilde{\sigma}',\phi}$,
  then for all pairs $(\tilde{t},\tilde{\sigma}',\phi)$ it holds that $\Sat(\Phi\land\phi)$ implies
  that $e,\sigma\normalise t,\sigma'$ with $t,\sigma'\Consistent_{M}\tilde{t},\tilde{\sigma'},\Phi\land\phi$.
\end{lemma}

\begin{lemma}[Soundness of striding]
  \label{lem:soundstride}
  for all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $t,\sigma\Consistent_{M}\tilde{t},\tilde{\sigma},\Phi$ implies
  that if $\tilde{t},\tilde{\sigma}\stride\overline{\tilde{t}',\tilde{\sigma}',\phi}$,
  then for all pairs $(\tilde{t}',\tilde{\sigma}',\phi)$ it holds that $\Sat(\Phi\land\phi)$ implies
  that $t,\sigma\hat{\stride}t',\sigma'$ with $t',\sigma'\Consistent_{M}\tilde{t'},\tilde{\sigma'},\Phi\land\phi$.
\end{lemma}

\begin{lemma}[Soundness of evaluation]
  \label{lem:soundeval}
  For all concrete expressions $e$, concrete states $\sigma$, symbolic expressions $\tilde{e}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $e,\sigma\Consistent_{M}\tilde{e},\tilde{\sigma},\Phi$ implies
  that if $\tilde{e},\tilde{\sigma}\eval\overline{\tilde{v},\tilde{\sigma}',\phi}$,
  then for all pairs $(\tilde{v},\tilde{\sigma}',\phi)$ it holds that $\Sat(\Phi\land\phi)$ implies
  that $e,\sigma\hat{\eval}v,\sigma'$ with $v,\sigma'\Consistent_{M}\tilde{v},\tilde{\sigma'},\Phi\land\phi$.
\end{lemma}




\begin{lemma}[Completeness of handling]
  \label{lem:completeHandle}
  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $t,\sigma\Consistent_{M}\tilde{t},\tilde{\sigma},\Phi$ implies
  that for all inputs $i$ such that $t,\sigma\handle{i}t',\sigma'$,
  there exists a symbolic input $\tilde{i}$, $\tilde{i}\sim i$ such that
  $\tilde{t},\tilde{\sigma}\handle{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi}$,
  and for all pairs $(\tilde{t}',\tilde{\sigma}',\tilde{i},\phi)$ we have that $\Sat(\Phi\land\phi)$ implies $t',\sigma'\Consistent_{M.[s\mapsto c]}\tilde{t}',\tilde{\sigma}',\Phi\land\phi$ where where $s\in\tilde{i}$ and $c\in i$.
\end{lemma}

\begin{lemma}[Completeness of normalisation]
  \label{lem:completeNormalise}
  For all concrete expressions $e$, concrete states $\sigma$, symbolic expressions $\tilde{e}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $e,\sigma\Consistent_{M}\tilde{e},\tilde{\sigma},\Phi$
  and $e,\sigma\hat{\normalise} t,\sigma'$,
  then $\tilde{e},\tilde{\sigma}\normalise\overline{\tilde{t},\tilde{\sigma}',\phi}$,
  and for all pairs $(\tilde{t},\tilde{\sigma}',\phi)$ we have that $\Sat(\Phi\land\phi)$ implies $t,\sigma'\Consistent_{M}\tilde{t},\tilde{\sigma}',\Phi\land\phi$.
\end{lemma}

\begin{lemma}[Completeness of striding]
  \label{lem:completeStride}
  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $t,\sigma\Consistent_{M}\tilde{t},\tilde{\sigma},\Phi$
  and $t,\sigma\hat{\stride} t',\sigma'$,
  then $\tilde{t},\tilde{\sigma}\stride\overline{\tilde{t'},\tilde{\sigma}',\phi}$,
  and for all pairs $(\tilde{t'},\tilde{\sigma}',\phi)$ we have that $\Sat(\Phi\land\phi)$ implies $t',\sigma'\Consistent_{M}\tilde{t'},\tilde{\sigma}',\Phi\land\phi$.
\end{lemma}

\begin{lemma}[Completeness of evaluate]
  \label{lem:completeEval}
  For all concrete expressions $e$, concrete states $\sigma$, symbolic expressions $\tilde{e}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $e,\sigma\Consistent_{M}\tilde{e},\tilde{\sigma},\Phi$
  and $e,\sigma\hat{\eval} v,\sigma'$,
  then $\tilde{e},\tilde{\sigma}\eval\overline{\tilde{v},\tilde{\sigma}',\phi}$,
  and for all pairs $(\tilde{v},\tilde{\sigma}',\phi)$ we have that $\Sat(\Phi\land\phi)$ implies $v,\sigma'\Consistent_{M}\tilde{v},\tilde{\sigma}',\Phi\land\phi$.
\end{lemma}

% The problem with the lemma's above, is that they assume that you start out with the same task and state.
% In the case of $\Evaluate$ and $\Simulate$, this is not true, since in the sequential application of (symbolic) drive, the expressions differ.
% Below, a graphical representation is shown of this process.
\begin{figure}

\begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 3cm, % distance between nodes
            semithick % line style
        ]


        % j = 0
        \node (0)  {$(t,\sigma)$};
        \node (l0) [right of=0] {$t,\sigma\Consistent_\emptyset t,\sigma,\True$};

        % j = 1
        \node (c1) [below left of=0] {$(t_1,\sigma_1)$};
        \node (s1) [below right of=0] {$(\tilde{t_1},\tilde{\sigma_1},\phi_1)$};
        \node (l1) [right of=s1,text width=4cm] {\begin{tabular}{l}
        $t_1,\sigma_1\Consistent_{[s_1\mapsto c_1]}\tilde{t_1},\tilde{\sigma_1},\phi_1$\\
                                  $\Sat(\phi_1)$\\
                                  $\Value(t_1,\sigma_1)=\bot$\end{tabular}};

        %
        \node (cc) [below of=c1] {\vdots};
        \node (ss) [below of=s1] {\vdots};

        % j = k
        \node (ck) [below of=cc] {$(t_1,\sigma_1)$};
        \node (sk) [below of=ss] {$(\tilde{t_1},\tilde{\sigma_1},\phi_1)$};
        \node (lk) [right of=sk,text width=4cm] {\begin{tabular}{l}
        $t_k,\sigma_k\Consistent_{[s_1\mapsto c_1,\cdots,s_k\mapsto c_k]}\tilde{t_k},\tilde{\sigma_k},\phi_1\land\cdots\land\phi_k$\\
        $\Sat(\phi_1\land\cdots\land\phi_k)$\\
        $\Value(t_k,\sigma_k)=\bot$\end{tabular}};

        %
        \node (ccc) [below of=ck] {\vdots};
        \node (sss) [below of=sk] {\vdots};

        \node (cn) [below of=ccc] {$(t_n,\sigma_n)$};
        \node (sn) [below of=sss] {$(\tilde{t_n},\tilde{\sigma_n},\phi_n)$};
        \node (l1) [right of=sn,text width=4cm] {\begin{tabular}{l}
        $t_n,\sigma_n\Consistent_{[s_1\mapsto c_1,\cdots,s_n\mapsto c_n]}\tilde{t_n},\tilde{\sigma_n},\phi_1\land\cdots\land\phi_n$\\
        $\Sat(\phi_1\land\cdots\land\phi_n)$\\
        $\Value(t_n,\sigma_n)=v$\end{tabular}};

        \path[->] (0) edge node {$i_1$} (c1);
        \path[->] (0) edge node {$\tilde{i_1}$} (s1);

        \path[->] (c1) edge node { } (cc);
        \path[->] (s1) edge node { } (ss);

        \path[->] (cc) edge node { $i_k$} (ck);
        \path[->] (ss) edge node { $\tilde{i_k}$} (sk);

        \path[->] (ck) edge node { } (ccc);
        \path[->] (sk) edge node { } (sss);

        \path[->] (ccc) edge node { } (cn);
        \path[->] (sss) edge node { } (sn);

        \path[->] (ccc) edge node {$i_n$} (cn);
        \path[->] (sss) edge node {$\tilde{i_n}$} (sn);

        \path[dashed,->] ([yshift=.25em]c1.east) edge node {\cref{lem:completedriving}} ([yshift=.25em]s1.west);
        \path[dashed,->] ([yshift=-.25em]s1.west) edge node {\cref{lem:sounddriving}} ([yshift=-.25em]c1.east);

        \path[dashed,->] ([yshift=.25em]ck.east) edge node {\cref{lem:completedriving}} ([yshift=.25em]sk.west);
        \path[dashed,->] ([yshift=-.25em]sk.west) edge node {\cref{lem:sounddriving}} ([yshift=-.25em]ck.east);

        \path[dashed,->] ([yshift=.25em]cn.east) edge node {\cref{lem:completesimulate}} ([yshift=.25em]sn.west);
        \path[dashed,->] ([yshift=-.25em]sn.west) edge node {\cref{lem:soundsimulate}} ([yshift=-.25em]cn.east);

    \end{tikzpicture}
    \caption{Proof structure}
      \label{fig:proofstructure}
\end{figure}
% to be added to the figure above:\\
% $\Value(t_n,\sigma_n)=v$\\
% $\Value(t_{i<n},\sigma_{i<n})=\bot$\\
% etc
