% !TEX root=../main.tex

\section{Symbolic TopHat}
\label{sec:symbolic}

A symbolic execution semantics aims to execute a program without knowing its input.
Instead, symbols are fed into the program, and path conditions are recorded.

Consider the tiny example below.

\begin{TASK}
  $\lambda x,y \rightarrow \If{x>y}{(y,x)}{(x,y)}$
\end{TASK}

This program takes two values and returns a pair, where the second element is larger than the first.
When we run this program symbolically, we have to enter two symbols for $x$ and $y$, say $s0$ and $s1$ respectively.
There are two possible outcomes, namely\\
$(s1,s0)$, provided that $s0<s1$ and\\
$(s0,s1)$, provided that $s0\geq s1$\\

Now, the property that we want to prove for this program is that no matter what the input is, the second element should always be larger than the first.

$\psi(a,b)=b\geq a$

Looking at the two symolic runs, we can immediately conclude that the property holds.
Of course this is a trivial example, one can conclude or even prove that the property holds without symbolic execution.
But when applying this technique to larger programs, it is a powerful tool to show that a program behaves as expected.
\cref{sec:examples} illustrates this by applying symbolic execution to a larger example.




\begin{figure*}[t]
  \begin{function}
  \signature{\Simulate : \mathrm{Tasks} \times \mathrm{States} \times [\mathrm{Inputs}]  \times \mathrm{Predicates}
    \rightarrow \powerset{\mathrm{Values} \times [\mathrm{Inputs}] \times \mathrm{Predicates}}} \\
  \Simulate\ (t, \sigma, I, \phi) &=&\left\{
    \begin{array}{lr}
      \set{(v,I,\phi)}                                                                     & \Value(t,\sigma)=v\\
       \bigcup \set{ \Simulate'\ (\True, t, t', \sigma', I\oplus[i'], \phi\land\phi') \mid t, \sigma \drive{} t', \sigma', i', \phi' }                                                                &  \Value(t,\sigma)=\bot
    \end{array}
  \right.
    \\
  \addlinespace
  \signature{\Simulate' : \mathrm{Booleans} \times \mathrm{Tasks} \times \mathrm{Tasks} \times \mathrm{States} \times [\mathrm{Inputs}] \times \mathrm{Predicates}
    \rightarrow \powerset{\mathrm{Values} \times [\mathrm{Inputs}] \times \mathrm{Predicates}}} \\
  \Simulate'\ (\Again, t, t', \sigma', I, \phi) &=& \\
    \multicolumn{3}{L}{ \left\{
      \begin{array}{lr@{\ }c@{\ }l@{\ }c@{\ }l@{\ }c@{\ }r}
        \nothing                                                                                    & \neg\Sat(\phi) &&&&&&\\
        \set{(v, I, \phi)}                                                                & \Sat(\phi)     &\land& \Value(t',\sigma') = v &&&& \\
        \Simulate\ (t', \sigma', I, \phi)                                                           & \Sat(\phi)     &\land& \Value(t',\sigma') = \bot &\land& t' \neq t &&\\
        \bigcup \set{\Simulate'\ (\False, t', t'', \sigma'', I\oplus[i'], \phi\land\phi')
          \mid  t',\sigma' \drive{} t'', \sigma'', i', \phi'}                                       & \Sat(\phi)     &\land& \Value(t',\sigma') = \bot &\land& t' = t    &\land& \Again\\
        \nothing                                                                                    & \Sat(\phi)     &\land& \Value(t',\sigma') = \bot &\land& t' = t    &\land& \neg\Again
      \end{array}
      \right.}
\end{function}
  \caption{Simulation function definition.}
  \label{fig:simulate}
\end{figure*}
