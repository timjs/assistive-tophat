% !TEX root=../main.tex

\section{The TopHat language}
\label{sec:tophat}

Task-Oriented Programming (\TOP) is a paradigm first introduced by Plasmeijer et al.~\cite{DBLP:conf/ppdp/PlasmeijerLMAK12}.
It was created to improve the development of software that models collaboration.
\TOP provides programmers with a high level of programming abstraction,
while being expressive enough to describe real world collaborations.
It does so by using features from higher-order functional programming languages,
combined with the notion of \emph{tasks}.

\todo{Explain interactive at the core.}
\todo{Explain goal to support collaboration when executing workflows.}
Tasks model \emph{units of work}, which can be performed by a human or by a computer.
To support users during their work, tasks should be \emph{interactive}.
That is, users can enter or update information into the system by using \emph{editors}.
They can be \emph{observed}, so that other users or the system itself can make decisions based on the progress of the task.
Tasks can be combined into bigger tasks by using \emph{combinators}.
Basic combinators are chosen in such a way, that they represent a way of collaboration between users.
New combinators can be created by making use of basic combinators and the higher order facilities of the host language.

Tasks are typed.
Not only to ensure safety at runtime,
but also to automatically derive common program elements.
\TOP systems automatically generate user interfaces and manage persistent storage of information.
Programmers describe what work needs to be done in what way.
From this specification, a \TOP implementation generates a multi-user (web) application.

\todo{citations}
Currently, there are three systems implementing the ideas of \TOP.
The defacto standard is the \ITASKS framework,
which is an embedded domain specific language in the non-strict functional programming language Clean.
\MTASKS is a \TOP implementation specifically designed for embedded systems.
Steenvoorden, Naus, and Klinik created a formalisation of \TOP in \cite{},
called \TOPHAT.
This work builds further on \TOPHAT and \STOPHAT.

Since the idea was introduced, a lot of research as been done on \TOP.
However, the basic principle remain the same.
In the next subsections we describe the basic elements of every \TOP program.

% \TOP implementations like iTasks~\cite{????} also leverage aspects of the host language in order to allow for a higher level of abstraction,
% such as generic programming and higher order tasks. \todo{is dit wel of niet top?}
%
%
% The next section describes the formal \TOP implementation \TOPHAT.
TopHat (\TOPHAT) implements \TOP by embedding a task language in the simply typed lambda calculus with references, conditionals, primitive types and pairs.
Symbolic \TOPHAT extends this with \todo{Mention other features.}
References are used to model the shared data component of \TOP.
Below, the different components of \TOPHAT are explained in detail.
The complete syntax and semantics can be found in previous work~\cite{Steenvoorden2019}.


\subsection{Editors}

Editors form the entry points for interaction and communication with the outside world.

Editors are the most basic tasks.
They can be seen as an abstraction over widgets in a \GUI library or on webpage forms.
Users can change the value held by an editor, in the same way they can manipulate widgets in a \GUI.

When a \TOP implementation generates an application from a task specification, it derives user interfaces for the editors.
The appearance of an editor is influenced by its type.
For example, an editor for a string can be represented by a simple input field, a date by a calendar, and a location by a pin on a map.

There are three different editors in \TOPHAT.
\begin{description}
  \item[$\Edit v$] Valued editor.\\
    This editor holds a value $v$ of a certain type.
    The user can replace the value by a new value of the same type.
  \item[$\Enter \tau$] Unvalued editor.\\
    This editor holds no value, and can receive a value of type $\tau$.
    When that happens, it turns into a valued editor.
  \item[$\Update l$] Shared editor.\\
    This editor refers to a store location $l$.
    Its observable value is the value stored at that location.
    When it receives a new value, this value will be stored at location $l$.
\end{description}


\subsection{Combinators}

Editors can be combined into larger tasks using combinators.
The order in which editors and tasks are executed is specified with combinators. Tasks can be performed in sequence, in parallel or a choice can be made between tasks.


The following combinators are available in \TOPHAT.
Here, $t$ stands for tasks and $e$ for arbitrary expressions.
\begin{description}
  \item[$t \Then e$] Step.\\
    Users can work on task $t$.
    As soon as $t$ has a value, that value is passed on to the right hand side $e$.
    The expression $e$ is a function, taking the value as an argument, resulting in a new task.
  \item[$t \Next e$] User Step.\\
    Users can work on task $t$.
    When $t$ has a value, the step becomes enabled.
    Users can then send a continue event to the combinator.
    When that happens, the value of $t$ is passed to the right hand side, with which it continues.
  \item[$t_1 \And t_2$] Composition.\\
    Users can work on tasks $t_1$ and $t_2$ in at the same time.
  \item[$t_1 \Or t_2$] Choice.\\
    The system chooses between $t_1$ or $t_2$,
    based on which task first has a value.
    If both tasks have a value, the system chooses the left one.
  \item[$e_1 \Xor e_2$] User choice.\\
    A user has to make a choice between either the left or the right hand side.
    The user continues to work on the chosen task.
\end{description}

In addition to editors and combinators, \TOPHAT also contains the fail task ($\Fail$).
Programmers can use this task to indicate that a task is not reachable or viable.
When the right hand side of a step combinator evaluates to $\Fail$, the step will not proceed to that task.

\todo{Say something about guarded tasks. Needed for Philosophers example.}


\subsection{Shared data}

Tasks communicate with each other by passing data along control flow, or via globally shared data stores.

\todo{Describe value passing: sequential and through shares.}


\subsection{Observations}

Several observations can be made on tasks.
Using the value function $\Value$, the current value of a task can be determined.
The value function is a partial function, since not all tasks have a value.
For example empty editors and steps do not have a value.

One can also observe whether or not a task is failing, by means of the failing function $\Failing$.
The task $\Fail$ is failing, as is a parallel combination of failing tasks ($\Fail \And \Fail$).

The step combinator makes use of both functions in order to determine if it can step.
First, it uses $\Value$ to see if the left hand side produces a value.
If that is the case, it uses the $\Failing$ function to see if stepping to the right hand side is successful.

\begin{figure}[h]
  \centering \small
  \usemacro{O-Value}
  \caption{
    Value observation.
  } \label{}
\end{figure}


\subsection{Input}

Input events drive evaluation of tasks.
Because tasks are typed, input is typed as well.
Editors only accept input of the correct type.
Examples are replacing a value in an editor,
or sending a continue event to a user step.
When the system receives a valid event, it gives this event to the current task, which reduces to a new task.
Everything in between interaction steps is evaluated atomically with respect to inputs.
This means that tasks are normalised up to the point they await new user interactions.
% In this way the system communicates with the environment.

Input events are synchronous, which means the order of execution is completely determined by the order of the events.
In particular, the order of input events determine the progression of parallel branches.
