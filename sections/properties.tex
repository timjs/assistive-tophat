% !TEX root=../main.tex

\section{Properties}
\label{sec:properties}

We define an evaluation function that takes a task, state and list of inputs,
and returns the value of the task after application of all inputs.
This is a partial function since not all tasks have an observable value.

All elements of firsts are valid hints.

\begin{definition}[Evaluate]
  $t,\sigma\drive{I}^* v$
  \begin{align*}
    t,\sigma             & \drive{i_1} & t_1,\sigma_1\\
    t_1,\sigma_1         & \drive{i_2} & t_2,\sigma_2\\
                         & \vdots   & \\
    t_{n-1},\sigma_{n-1} & \drive{i_n} & t_n,\sigma_n
  \end{align*}
  With $\Value(t_n,\sigma_n)=v$\\
  $\Value(t_{i<n},\sigma_{i<n})=\bot$\\
  $I=i_1,\cdots,i_n$
\end{definition}

\subsection{Correctness of firsts}

The most important property we would like to prove, is the correctness of the hints calculated by firsts.
Intuitively, for a set of next step hints to be correct, they should be
- valid steps a user can actually take
- bring the user closer to the desired goal
- contain ALL steps that bring the user closer to their goal.

We separate this property into two parts.


\begin{lemma}[Soundness of firsts]
  \label{lem:soundfirsts}

For all tasks $t$, states $\sigma$ and goals $g$,
for every next step hint $(\tilde{i},\Phi)$ in $\Firsts(t,\sigma,g)$,
there exists a sequence of inputs $I$ and input $i$ such that $\tilde{i}\sim i$,
$\Sat([s\mapsto c]\Phi)$, $t,\sigma\drive{i} t',\sigma'\drive{I}^* v$ and $gv$.
\end{lemma}

\begin{proof}
  \cref{lem:soundfirsts} follows from the premise of \refrule{R-Firsts} and \cref{lem:soundsimulate} as follows.

  The premise of \refrule{R-Firsts} gives us that for every pair $\tilde{i},\Phi)$ produced by $\Firsts$,
  there exists a pair $(\tilde{v},\tilde{i}:\tilde{is},\Phi)$ with $\Sat(\Phi\land g \tilde{v})$.
  Then by \cref{lem:soundsimulate} we have that there exists a sequence of concrete inputs $I$ such that
  $t,\sigma\drive{I}^*v$ and $g v$.
\end{proof}

\begin{lemma}[Completeness of firsts]
  \label{lem:completefirsts}
  For all tasks $t$, states $\sigma$, lists of input $(i:is)$ and goals $g$,
  if $t,\sigma,\drive{i:is}^*v$ and $g v$, then there exists a symbolic input $\tilde{i}$ and path condition $\Phi$
  such that $(\tilde{i},\Phi)\in\Firsts(t,\sigma)$ with $\tilde{i}\sim i$ and $\Sat([s\mapsto c]\Phi)$ with $c\in i$ and $s\in i$.
\end{lemma}

\begin{proof}
  In order to prove that $i$ is contained in $\Firsts(t,\sigma)$, we need to show that the premise of \refrule{R-Firsts} holds.

  This means showing that $(\tilde{v},\tilde{i}:\tilde{is},\Phi)\in t,\sigma\drive{}^*$, with $\tilde{i}\sim i$ and $\Sat(\tilde{i}:\tilde{is}\land g\tilde{v})$. (fix notation of sat)

  By \cref{lem:completesimulate}, we directly obtain that this indeed exists. Therefore we know that $\tilde{i}$ and $\Phi$ exist.
\end{proof}


Since the $\Firsts$ function relies on the $\Simulate$ function, we can make use of soundness and completeness of that function with respect to $\Evaluate$, when proving the lemma's above.

\begin{lemma}[Soundness of simulate]
  \label{lem:soundsimulate}
  For all tasks $t$ and states $\sigma$
  such that $t,\sigma\drive{}^*\overline{\tilde{v},\tilde{I},\Phi}$
  then for all results $(\tilde{v},\tilde{I}=[\tilde{i}_0,\cdots,\tilde{i}_n],\Phi)$
  there exists a concrete input $I$ with the same length as the symbolic input $\tilde{I}$
  such that $t,\sigma\drive{I}^*v$
  with $[s_i\mapsto c_i]\tilde{v}=v$ and $[s_i\mapsto c_i]\Phi$
  where $s_i\in\tilde{i_i}$ and $c_i\in i_i$.
\end{lemma}

\begin{lemma}[Completeness of simulate]
  \label{lem:completesimulate}
  For all tasks $t$, states $\sigma$ and lists of input $I$
  such that $t,\sigma\drive{I}^*v$
  there exists a symbolic value $\tilde{v}$ and a symbolic input $\tilde{I}$ with the same length as $I$,
  such that $(\tilde{v},\tilde{I},\Phi)\in t,\sigma\drive{}^*$,
  with $\tilde{i_i}\sim i_i$, $[s_i\mapsto c_i]\tilde{v}=v$ and $[s_i\mapsto c_i]\Phi$,
  where $s_i\in\tilde{i_i}$ and $c_i\in i_i$.
\end{lemma}


$\Evaluate$ and $\Simulate$ make use of the driving and symbolic driving semantics respectively, so we again first prove those sound and complete with respect to each other.


\begin{definition}[Consistence relation $\mathds{C}$]
A concrete task $t$ and concrete state $\sigma$
are considered to be consistent with a symbolic task $\tilde{t}$, symbolic state $\tilde{\sigma}$ and path condition $\Phi$
under a certain mapping $M=[s_1\mapsto c_1,\cdots,s_n,\mapsto c_n]$, denoted as $\mathds{C}(t,\sigma,\tilde{t},\tilde{\sigma},\Phi,M)$
if and only if $M\tilde{t}=t$, $M\tilde{\sigma}=\sigma$ and $M\Phi$
\end{definition}

\begin{lemma}[Soundness of driving]
  \label{lem:sounddriving}
  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(t,\sigma,\tilde{t},\tilde{\sigma},\Phi,M)$ implies
  that for all pairs $(\tilde{t}',\tilde{\sigma}',\tilde{i},\phi)$ in $\tilde{t},\tilde{\sigma}\drive{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi}$,
  $\Sat(\Phi\land\phi)$ implies that there exists an input $i$ such that $\tilde{i}\sim i$,  $t,\sigma\drive{i}t',\sigma'$ and $\mathds{C}(t',\sigma',\tilde{t}',\tilde{\sigma}',\Phi\land\phi,M.[s\mapsto c])$ where where $s\in\tilde{i}$ and $c\in i$.
\end{lemma}

\begin{proof}[Soundness of driving]
  The symbolic driving semantics consists of only one rule, \refrule{SI-Handle}.
  Given that $\mathds{C}(t,\sigma,\tilde{t},\tilde{\sigma},\Phi,M)$ and $\tilde{t},\tilde{\sigma}\drive{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi_1}$,
  \cref{lem:soundhandle} gives us that for each pair $(\tilde{t}',\tilde{\sigma}',\tilde{i},\phi_1)$
  there exists an input $i$ such that $\tilde{i}\sim i$, $t,\sigma\handle{i}t',\sigma'$
  and $\mathds{C}(t',\sigma',\tilde{t'},\tilde{\sigma'},\Phi\land\phi_1,M.[s\mapsto c])$.

  Then, by \cref{lem:soundnorm}, given that $\tilde{t'},\tilde{\sigma'}\normalise\overline{\tilde{t''},\tilde{\sigma''}',\phi_2}$,
  we obtain that for each pair $(\tilde{t''},\tilde{\sigma''}',\phi_2)$, we have that $\Sat(\Phi\land\phi_1\land\phi_2)$ implies
  that $t',\sigma'\hat{\normalise}t'',\sigma''$ with $\mathds{C}(t'',\sigma'',\tilde{t''},\tilde{\sigma''},\Phi\land\phi_1\land\phi_2,M.[s\mapsto c])$.
\end{proof}



\begin{lemma}[Completeness of driving]
  \label{lem:completedriving}
  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(t,\sigma,\tilde{t},\tilde{\sigma},\Phi,M)$ implies
  that for all inputs $i$ such that $t,\sigma\drive{i}t',\sigma'$,
  there exists a symbolic input $\tilde{i}$, $\tilde{i}\sim i$ such that
  $\tilde{t},\tilde{\sigma}\drive{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi}$, $\Sat(\Phi\land\phi)$ and $\mathds{C}(t',\sigma',\tilde{t}',\tilde{\sigma}',\Phi\land\phi,M.[s\mapsto c])$ where where $s\in\tilde{i}$ and $c\in i$.
\end{lemma}

Where $\tilde{i}\sim i$ is defined as follows.

\begin{definition}[Input simulation]
  A symbolic input $\tilde{i}$ simulates a concrete input $i$ denoted as $\tilde{i}\sim i$ in the following cases.\\
  $s\sim a$, where $s$ is a symbol and $a$ a concrete action.\\
  $\tilde{i}\sim i\implies \First \tilde{i} \sim \First i$\\
  $\tilde{i}\sim i\implies \Second \tilde{i} \sim \Second i$
\end{definition}

And $s\in \tilde{i}$ and $c\in i$ are defined as follows.

\begin{definition}[Value from input]
  $c\in \First i = c\in i $\\
  $c\in \Second i = c\in i $\\
  $c\in a = a $
\end{definition}

\begin{definition}[Symbol from input]
  $s\in \First \tilde{i} = s\in \tilde{i} $\\
  $s\in \Second \tilde{i} = s\in \tilde{i} $\\
  $s\in a = a $
\end{definition}

Since the driving semantics depends on the handling and normalisation semantics, we need to show that they too are sound and complete, before we can prove the lemma's above.


\begin{lemma}[Soundness of handling]
  \label{lem:soundhandle}

  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(t,\sigma,\tilde{t},\tilde{\sigma},\Phi,M)$ implies
  that for all symbolic inputs $\tilde{i}$ such that $\tilde{t},\tilde{\sigma}\handle{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi}$ and
  for all pairs $(\tilde{t}',\tilde{\sigma}',\tilde{i},\phi)$,
  $\Sat(\Phi\land\phi)$ implies that there exists an input $i$ such that $\tilde{i}\sim i$,  $t,\sigma\handle{i}t',\sigma'$ and $\mathds{C}(t',\sigma',\tilde{t}',\tilde{\sigma}',\Phi\land\phi,M.[s\mapsto c])$ where where $s\in\tilde{i}$ and $c\in i$.

\end{lemma}



\begin{lemma}[Soundness of normalisation]
  \label{lem:soundnorm}
  For all concrete expressions $e$, concrete states $\sigma$, symbolic expressions $\tilde{e}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(e,\sigma,\tilde{e},\tilde{\sigma},\Phi,M)$ implies
  that if $\tilde{e},\tilde{\sigma}\normalise\overline{\tilde{t},\tilde{\sigma}',\phi}$,
  then for all pairs $(\tilde{t},\tilde{\sigma}',\phi)$ it holds that $\Sat(\Phi\land\phi)$ implies
  that $e,\sigma\hat{\normalise}t,\sigma'$ with $\mathds{C}(t,\sigma',\tilde{t},\tilde{\sigma'},\Phi\land\phi,M)$.
\end{lemma}

\begin{lemma}[Soundness of striding]
  for all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(t,\sigma,\tilde{t},\tilde{\sigma},\Phi,M)$ implies
  that if $\tilde{t},\tilde{\sigma}\stride\overline{\tilde{t}',\tilde{\sigma}',\phi}$,
  then for all pairs $(\tilde{t}'',\tilde{\sigma}',\phi)$ it holds that $\Sat(\Phi\land\phi)$ implies
  that $t,\sigma\hat{\stride}t',\sigma'$ with $\mathds{C}(t',\sigma',\tilde{t'},\tilde{\sigma'},\Phi\land\phi,M)$.
\end{lemma}

\begin{lemma}[Soundness of evaluation]
  For all concrete expressions $e$, concrete states $\sigma$, symbolic expressions $\tilde{e}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(e,\sigma,\tilde{e},\tilde{\sigma},\Phi,M)$ implies
  that if $\tilde{e},\tilde{\sigma}\eval\overline{\tilde{v},\tilde{\sigma}',\phi}$,
  then for all pairs $(\tilde{v},\tilde{\sigma}',\phi)$ it holds that $\Sat(\Phi\land\phi)$ implies
  that $e,\sigma\hat{\eval}v,\sigma'$ with $\mathds{C}(v,\sigma',\tilde{v},\tilde{\sigma'},\Phi\land\phi,M)$.
\end{lemma}




\begin{lemma}[Completeness of handling]
  \label{lem:completeHandle}
  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(t,\sigma,\tilde{t},\tilde{\sigma},\Phi,M)$ implies
  that for all inputs $i$ such that $t,\sigma\handle{i}t',\sigma'$,
  there exists a symbolic input $\tilde{i}$, $\tilde{i}\sim i$ such that
  $\tilde{t},\tilde{\sigma}\handle{}\overline{\tilde{t}',\tilde{\sigma}',\tilde{i},\phi}$,
  and for all pairs $(\tilde{t}',\tilde{\sigma}',\tilde{i},\phi)$ we have that $\Sat(\Phi\land\phi)$ implies $\mathds{C}(t',\sigma',\tilde{t}',\tilde{\sigma}',\Phi\land\phi,M.[s\mapsto c])$ where where $s\in\tilde{i}$ and $c\in i$.
\end{lemma}

\begin{lemma}[Completeness of normalisation]
  \label{lem:completeNormalise}
  For all concrete expressions $e$, concrete states $\sigma$, symbolic expressions $\tilde{e}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(e,\sigma,\tilde{e},\tilde{\sigma},\Phi,M)$
  and $e,\sigma\hat{\normalise} t,\sigma'$,
  then $\tilde{e},\tilde{\sigma}\normalise\overline{\tilde{t},\tilde{\sigma}',\phi}$,
  and for all pairs $(\tilde{t},\tilde{\sigma}',\phi)$ we have that $\Sat(\Phi\land\phi)$ implies $\mathds{C}(t,\sigma',\tilde{t},\tilde{\sigma}',\Phi\land\phi,M)$.
\end{lemma}

\begin{lemma}[Completeness of striding]
  \label{lem:completeStride}
  For all concrete tasks $t$, concrete states $\sigma$, symbolic tasks $\tilde{t}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(t,\sigma,\tilde{t},\tilde{\sigma},\Phi,M)$
  and $t,\sigma\hat{\stride} t',\sigma'$,
  then $\tilde{t},\tilde{\sigma}\stride\overline{\tilde{t'},\tilde{\sigma}',\phi}$,
  and for all pairs $(\tilde{t'},\tilde{\sigma}',\phi)$ we have that $\Sat(\Phi\land\phi)$ implies $\mathds{C}(t',\sigma',\tilde{t'},\tilde{\sigma}',\Phi\land\phi,M)$.
\end{lemma}

\begin{lemma}[Completeness of evaluate]
  \label{lem:completeEval}
  For all concrete expressions $e$, concrete states $\sigma$, symbolic expressions $\tilde{e}$, symbolic states $\tilde{\sigma}$ path conditions $\Phi$ and mappings $M$,
  we have that $\mathds{C}(e,\sigma,\tilde{e},\tilde{\sigma},\Phi,M)$
  and $e,\sigma\hat{\eval} v,\sigma'$,
  then $\tilde{e},\tilde{\sigma}\eval\overline{\tilde{v},\tilde{\sigma}',\phi}$,
  and for all pairs $(\tilde{v},\tilde{\sigma}',\phi)$ we have that $\Sat(\Phi\land\phi)$ implies $\mathds{C}(v,\sigma',\tilde{v},\tilde{\sigma}',\Phi\land\phi,M)$.
\end{lemma}

% The problem with the lemma's above, is that they assume that you start out with the same task and state.
% In the case of $\Evaluate$ and $\Simulate$, this is not true, since in the sequential application of (symbolic) drive, the expressions differ.
% Below, a graphical representation is shown of this process.

\begin{tikzpicture}[
            > = stealth, % arrow head style
            shorten > = 1pt, % don't touch arrow head to node
            auto,
            node distance = 3cm, % distance between nodes
            semithick % line style
        ]


        % j = 0
        \node (0)  {$(t,\sigma)$};
        \node (l0) [right of=0] {$\mathds{C}(t,\sigma,t,\sigma,\True,\emptyset)$};

        % j = 1
        \node (c1) [below left of=0] {$(t_1,\sigma_1)$};
        \node (s1) [below right of=0] {$(\tilde{t_1},\tilde{\sigma_1},\phi_1)$};
        \node (l1) [right of=s1,text width=4cm] {\begin{tabular}{l}
        $\mathds{C}(t_1,\sigma_1,\tilde{t_1},\tilde{\sigma_1},\phi_1,[s_1\mapsto c_1])$\\
                                  $\Sat(\phi_1)$\\
                                  $\Value(t_1,\sigma_1)=\bot$\end{tabular}};

        %
        \node (cc) [below of=c1] {\vdots};
        \node (ss) [below of=s1] {\vdots};

        % j = k
        \node (ck) [below of=cc] {$(t_1,\sigma_1)$};
        \node (sk) [below of=ss] {$(\tilde{t_1},\tilde{\sigma_1},\phi_1)$};
        \node (lk) [right of=sk,text width=4cm] {\begin{tabular}{l}
        $\mathds{C}(t_k,\sigma_k,\tilde{t_k},\tilde{\sigma_k},\phi_1\land\cdots\land\phi_k,[s_1\mapsto c_1,\cdots,s_k\mapsto c_k])$\\
        $\Sat(\phi_1\land\cdots\land\phi_k)$\\
        $\Value(t_k,\sigma_k)=\bot$\end{tabular}};

        %
        \node (ccc) [below of=ck] {\vdots};
        \node (sss) [below of=sk] {\vdots};

        \node (cn) [below of=ccc] {$(t_n,\sigma_n)$};
        \node (sn) [below of=sss] {$(\tilde{t_n},\tilde{\sigma_n},\phi_n)$};
        \node (l1) [right of=sn,text width=4cm] {\begin{tabular}{l}
        $\mathds{C}(t_n,\sigma_n,\tilde{t_n},\tilde{\sigma_n},\phi_1\land\cdots\land\phi_n,[s_1\mapsto c_1,\cdots,s_n\mapsto c_n])$\\
        $\Sat(\phi_1\land\cdots\land\phi_n)$\\
        $\Value(t_n,\sigma_n)=v$\end{tabular}};

        \path[->] (0) edge node {$i_1$} (c1);
        \path[->] (0) edge node {$\tilde{i_1}$} (s1);

        \path[->] (c1) edge node { } (cc);
        \path[->] (s1) edge node { } (ss);

        \path[->] (cc) edge node { $i_k$} (ck);
        \path[->] (ss) edge node { $\tilde{i_k}$} (sk);

        \path[->] (ck) edge node { } (ccc);
        \path[->] (sk) edge node { } (sss);

        \path[->] (ccc) edge node { } (cn);
        \path[->] (sss) edge node { } (sn);

        \path[->] (ccc) edge node {$i_n$} (cn);
        \path[->] (sss) edge node {$\tilde{i_n}$} (sn);

        \path[dashed,->] ([yshift=.25em]c1.east) edge node {\cref{lem:completedriving}} ([yshift=.25em]s1.west);
        \path[dashed,->] ([yshift=-.25em]s1.west) edge node {\cref{lem:sounddriving}} ([yshift=-.25em]c1.east);

        \path[dashed,->] ([yshift=.25em]ck.east) edge node {\cref{lem:completedriving}} ([yshift=.25em]sk.west);
        \path[dashed,->] ([yshift=-.25em]sk.west) edge node {\cref{lem:sounddriving}} ([yshift=-.25em]ck.east);

        \path[dashed,->] ([yshift=.25em]cn.east) edge node {\cref{lem:completesimulate}} ([yshift=.25em]sn.west);
        \path[dashed,->] ([yshift=-.25em]sn.west) edge node {\cref{lem:soundsimulate}} ([yshift=-.25em]cn.east);

    \end{tikzpicture}

% to be added to the figure above:\\
% $\Value(t_n,\sigma_n)=v$\\
% $\Value(t_{i<n},\sigma_{i<n})=\bot$\\
% etc
