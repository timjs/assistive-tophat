% !TEX root=../main.tex

\section{Introduction}
\label{sec:intro}

%% There are many workflow systems
Software that supports people working together is used in most workplaces nowadays.
Its aim is to automate business workflows, in order to simplify processes, to improve service, or to contain cost.
In settings like hospitals, first responders and military operations, these systems could even prevent the loss of lives.

%% They are a problem because
Automation and digitalisation of workflows and business processes comes at a cost.
For end users it can be hard to see how an action influences their desired goal.
They are unable to oversee the complete flow of the process
and there might be an abundance of data that they are not fully aware of.
End users might wonder if checking a box may prevent them, or someone else, from reaching their goal,
or ask themselves if they have taken all information into consideration before making a decision.

%% Our approach overcomes this because
To overcome these difficulties, we propose to integrate a next step hint assistive system into workflow software.
By combining previous research on symbolic execution for Task-Oriented Programming~\cite{Naus2019} and end-user feedback systems for rule based problems~\cite{DBLP:conf/sfp/NausJ16},
we develop a next step hint end-user feedback system for the Task-Oriented Programming language \TOPHAT~\cite{DBLP:conf/ppdp/SteenvoordenNK19}.
Our solution, which we call Assistive \TOPHAT, generates next step hints from existing code, and does not require extra work by the programmer.
To our knowledge, this is the first work employing symbolic execution to automatically generate next-step hints for end users.

%% What is the advantage of our system?
Providing next step hints to end users will provide them with a quick insight in to their situation.
It reduces the chance of human error, while still allowing the user to intervene if required.
The quality of decisions will improve, raising the overall performance.

%% What do we do in this paper?
In this paper we will introduce Task-Oriented Programming and the \TOPHAT language for readers unfamiliar with either of them,
followed by some illustrative examples.
Building further on this foundation we show how we use symbolic execution to automatically generate next step hints for end users.
It is crucial that these hints are valid, meaning they allow users to reach the desired goal.
Therefore we prove correctness for the automatic hint generation system.
Our hint generation system relies on symbolic execution as presented in earlier work~\cite{Naus2019}.
There, we proved correctness for the symbolic semantics for single user inputs.
Here, here we prove the entire symbolic system to be correct, i.e. for a sequence of user inputs.


\subsection{Contributions}

This paper makes the following contributions.

\begin{itemize}
  \item We describe an automatic end user next step feedback system for \TOPHAT, called Assistive \TOPHAT, based on a previously presented symbolic semantics.
  \item We prove the symbolic execution semantics of \TOPHAT to be correct for sequential inputs.
  \item We prove soundness and completeness of next step hints generated by this system.
  \item We present an implementation of the user feedback system in Haskell.
\end{itemize}


\subsection{Structure}

\cref{sec:tophat} first introduces the Task-Oriented Programming (\TOP) paradigm and the Task-Oriented Programming language \TOPHAT.
\cref{sec:examples} lists three example programs to illustrate how \TOPHAT works and to show what we like to achieve with Assistive \TOPHAT.
In \cref{sec:symbolic} we introduce briefly the symbolic execution semantics for \TOPHAT.
\cref{sec:assistive} follows with a description of assistive \TOPHAT
and describes the implementation of the system in Haskell.
In \cref{sec:properties} soundness and completeness of the assistive system are shown.
% An implementation of the system in Haskell is described in \cref{sec:implementation}.
\cref{sec:relatedwork} gives an overview of related work, and finally \cref{sec:conclusion} concludes.
