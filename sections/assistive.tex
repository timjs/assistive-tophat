% !TEX root=../main.tex

\section{Generating hints for TopHat}
\label{sec:assistive}
The section introduces our Assistive \TOPHAT system.
%What do we wanna do?
The goal of Assistive \TOPHAT is to provide next step hints, that brings users closer to their goal.
During the execution of a \TOPHAT program, users are presented with input fields, choices and continue buttons.
The way in which the task progresses and the resulting task value depends on their input.
For any point in the execution, we want to present the user with all options that are on the path to the goal that they have selected.
These options are either concrete steps, like continue, pick the left task or pick the right task,
or a value to be entered into an editor.
Since the concrete value also influences the flow of the program, these values can come with restrictions.
For example, enter an integer, but this integer must be larger than zero.

%How do we do this?

In order to calculate next step hints, first a goal must be formulated.
Since we are concerned with the resulting task value, the goal must be a predicate over the resulting value.
A task $\tilde{t}$ is considered done, as soon as it has an observable value $\tilde{v}$.

\begin{figure}
  \usemacro{O-Hints}
  \caption{Definition of next step hint function.}
  \label{fig:hints}
\end{figure}


Hints are calculated by means of the $\Hints$ function listed in \cref{fig:hints}.
As input it receives the task $t$ and state $\sigma$, together with the goal predicate $g$.
First, the simulate function is called on the task and input.
We only want to use the symbolic executions that satisfy the goal condition.
Executions that satisfy the goal $g(\tilde{v})$ are selected.
Since $\tilde{v}$ could contain symbols, it might be the case that $g(\tilde{v})$ is symbolic.
Therefore, we also require that the conjunction with the path condition $\Phi$ is satisfiable ($\Sat(\Phi\land g(\tilde{v}))$).

From the executions that fulfil this requirement, we return the first symbolic input $\tilde{i}$ from the complete list of inputs $\tilde{i}::\tilde{I}$,
together with the full condition that must hold ($\Sat(\Phi\land g(\tilde{v}))$).
The resulting set contains pairs of symbolic input guarded by a condition.

%How is the result of hints used?

When a user requests a next step hint, the current task and state are passed to $\Hints$, together with the selected goal.
The resulting set cannot directly be presented to the user.
Pairs containing a concrete step ($\Continue,\Left,\Right$), can be given as hints without their path condition.
Pairs containing a symbolic input as hint ($s,\First s,$ etc) should be presented with the path condition.
Since the path condition contains all constraints of the symbolic execution, it may contain constraints on symbols other than the next step hint.
These constraints should be removed from the information shown to the user, as they do not include useful information.


\todo{Write something here about function that removes redundant constraints.}

\cref{sec:assistivedining,sec:assistivetax} describe the application of assistive \TOPHAT to two examples from \cref{sec:examples}.
Then in \cref{sec:implementation}, our implementation of assistive \TOPHAT is presented.


\subsection{Tax subsidy request}
\label{sec:assistivetax}

%recall
\cref{sec:tax} lists an example program in \TOPHAT for applying for a solar panel tax refund.

%what hints do we want to give?
In order to calculate next step hints for the end-user, we employ the $\Hints$ function.

%write the goal
The goal of the user, receiving a refund larger than zero, can be formulated as $\lambda \tuple{v,\_,\_,\_,\_}\rightarrow v>0$.

%what does the result of H look like?
When we run the simulation function $\simulate$, we obtain all symbolic results, as listed in \cref{table:tax}.

\begin{table}[ht]
  \centering
  \begin{tabular}{LLL}
    \toprule
    \text{Symbolic value} & \text{Symbolic input} & \text{Path condition} \\
    \midrule
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second \First, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second \First, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\Second \First, \First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\Second \First, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \Second \First, \First \First s_{\id{a}}, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \Second \First, \First \Second s_{\id{i}}, \Second] & (\Today-s_{\id{i}}) < \OneYear \\
    \midrule
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second \First, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second \First, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\Second \First, \First \First s_{\id{a}}, \First \Second s_{\id{i}}, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\Second \First, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \Second \First, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \Second \First, \First \Second s_{\id{i}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\Second \Second,\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\Second, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\First \Second s_{\id{i}}, \Second, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, \Today} & [\First \First s_{\id{a}}, \Second, \First \Second s_{\id{i}}, \First]  & \True \\
    \bottomrule
  \end{tabular}
  \caption{}
  \label{table:tax}
\end{table}
\todo{What shall we do with this table?}
\todo{Caption!}

The top half of the table shows all symbolic runs.
When we filter on the goal $g$, we obtain the bottom selection.
From these runs, we can conclude that invoiceAmount should be larger than zero in order for the result to be larger than zero. This results in an additional constraint.
\todo{complete this section}
% In the end, we can use the above to give hints to the user.
%
% First, a date must be entered. Then the user can choose to ender an amount larger than zero, a date that is within 365 from now, or a "RL".
% etc.


\subsection{Dining Computer Scientists}
\label{sec:assistivedining}

%recall
Recall the example program Dining Computer Scientists from \cref{sec:dining}.
Three computer scientist sit at a table and have to coordinate in order to eat their meals.

%what hints do we want to give?
We want to calculate all possible next steps that lead to the goal.
The goal in this example is for all computer scientists to finish their meal.

%write the goal
In terms of the resulting task value, this means that we want to arrive at the value "Full bellies".
Witten as a predicate, we get $g=\lambda v\rightarrow v = "\text{Full bellies}"$.

%what does the result of H look like?
Let us assume that both Grace Hopper and Ada Lovelace have already picked up the forks to their left (fork1 and fork2 respectively).
We then find ourselves in the following situation.


\begin{align*}
t =\ &\text{scientist} "\text{Alan Turing}" \text{fork0}\ \text{fork1} \And\\
    &\unit \Next \lambda \unit .\\
    &\Quad \If{!\text{fork2}}{\text{fork1} := \True}{\Fail} \And\\
    &\unit \Next \lambda \unit .\\
    &\Quad \If{!\text{fork0}}{\text{fork2} := \True}{\Fail} Then \lambda \_.\\
    &\Quad \Edit "\text{Full bellies}"\\
\sigma =\ &\{\text{fork0}\mapsto \True, \text{fork1}\mapsto \False,\text{fork2}\mapsto \False\}
\end{align*}

Calling $\Hints(t,\sigma,g)$ will result in the following set.

$\{ \tuple{\Second\Second\Continue,\True}\}$

This means that the only step towards the goal $g$ is for Ada Lovelace to pick up the right fork.
Although it is also possible for Alan Turing to pick up the fork to his left, this step is not a valid hint.
Performing this action will result in deadlock.


\subsection{Implementation}
\label{sec:implementation}

\todo{Write this section (Tim).}
% \lstset{language=Haskell}
% \footnotesize\noindent%
% \texttt{firsts :: MonadTrack Text m => MonadSupply Nat m => MonadState Heap m => MonadZero m =>}\\
% \texttt{Val ('TyTask ('TyPrim t)) -> Goal t -> m ( Input, Pred 'TyPrimBool )}\\
% %\texttt{firsts t g = [ ( i, p' ) | ( v, i:_, p ) <- simulate t [] Yes, let p' = p :/\: g v, satisfiable p' ]}
% \normalsize
