% !TEX root=../main.tex

\section{Properties}
\label{sec:properties}

We define an evaluation function that takes a task, state and list of inputs,
and returns the value of the task after application of all inputs.
This is a partial function since not all tasks have an observable value.

\begin{figure*}[t]
  \begin{function}
    \signature{\Evaluate : \mathrm{Tasks} \times \mathrm{States} \times [\mathrm{Inputs}]
      \rightarrow \mathrm{Values}} \\
    \Evaluate\ (t,\sigma,[])       &=& \Value(t,\sigma)\\
    \Evaluate\ (t, \sigma, (i:is)) &=& \left\{
      \begin{array}{lr}
        v                                                                                 & \Value(t,\sigma)=v\\
        \Evaluate\ (t',\sigma',is)                                                                &  \Value(t,\sigma)=\bot \land t,\sigma\xRightarrow[]{i}t',\sigma'
      \end{array}
    \right.
  \end{function}
  \caption{evaluate function definition.}
  \label{fig:evaluate}
\end{figure*}

All elements of firsts are valid hints.


\subsection{Correctness of firsts}

The most important property we would like to prove, is the correctness of the hints calculated by firsts.
Intuitively, for a set of next step hints to be correct, they should be
- valid steps a user can actually take
- bring the user closer to the desired goal
- contain ALL steps that bring the user closer to their goal.

We separate this property into two parts.


\begin{lemma}[Soundness of firsts]
  \label{lem:soundfirsts}

  For all tasks $t$, states $\sigma$ and goals $g$,
  such that for all $(i,\phi)\in firsts\ (t,\sigma,g)$,
  there exists a mappings $M = [s_0\mapsto c_0,\cdots,s_n\mapsto c_n]$
  such that $t,M \sigma \xRightarrow[]{M i} t',\sigma'$.
  Subsequently, there exists a sequence of inputs $I$ such that $\Evaluate (t',\sigma',I) = v$
  with $g v = \True$.
  \todo{strictly speaking, this allows for empty/bogus hints that do not get CLOSER to the goal.}
\end{lemma}


\begin{lemma}[Completeness of firsts]
  \label{lem:completefirsts}

  For all tasks $t$, states $\sigma$, lists of inputs $(i:is)$ and goals $g$,
  such that $\Evaluate\ (t,\sigma,(i:is))=v$ with $g\ v =\True$,
  then $i\in firsts\ (t,\sigma,g)$.

\end{lemma}


Since the $\Firsts$ function relies on the $\Simulate$ function, we can make use of soundness and completeness of that function with respect to $\Evaluate$, when proving the lemma's above.

\begin{lemma}[Soundness of simulate]
  \label{lem:soundsimulate}

  For all tasks $t$, states $\sigma$,
  such that for all $(v,I,\phi)\in \Simulate (t,\sigma,[],\True)$,
  there exists a mapping $M = [s_0\mapsto c_0,\cdots,s_n\mapsto c_n]$
  such that $M\phi$ implies $\Evaluate (M t,M \sigma,M I) = M v$.
\end{lemma}

\begin{lemma}[Completeness of simulate]
  \label{lem:completesimulate}
  For all tasks $t$, states $\sigma$, lists of inputs $I$,
  such that $\Evaluate\ (t,\sigma,I)=v$,
  then there exists a mapping $M = [c_0\mapsto s_0,\cdots,c_n\mapsto s_n]$
  such that $(M v,M I,\phi)\in\Simulate(t,\sigma,[],\True)$ with $M \phi$.
\end{lemma}


$\Evaluate$ and $\Simulate$ make use of the driving and symbolic driving semantics respectively, so we again first prove those sound and complete with respect to each other.

\begin{lemma}[Soundness of driving]
  \label{lem:sounddriving}
  For all tasks $t$ and states $\sigma$,
  if $t,\sigma\drive{} \overline{t_s',\sigma_s',i_s,\phi}$
  then for all tuples $(t_s',\sigma_s',i_s,\phi)$,
  there exists an $i_c$ such that
  $t,\sigma\drive{i_c}t_c',\sigma_c'$
  with $i_c\sim i_s$, $[s\mapsto c]t_s'=t_c'$ and $[s\mapsto c]\sigma_s'=\sigma_c'$ where $s\in i_s$ and $c\in i_c$.
\end{lemma}

\begin{lemma}[Completeness of driving]
  \label{lem:completedriving}
  For all tasks $t$, states $\sigma$ and inputs $i_c$,
  if $t,\sigma\drive{i_c}t_c',\sigma_c'$,
  then there exists an $i_s\sim i_c$, $t_s'$ and $\sigma_s'$
  such that $t,\sigma\drive{}t_s',\sigma_s',i_s,\phi$
  with $[s\mapsto c]t_s'=t_c'$, $[s\mapsto c]\sigma_s'=\sigma_c'$ and $[s\mapsto c]\phi$, where $s\in i_s$ and $c\in i_c$.
\end{lemma}
Where $i_c\sim i_s$ is defined as follows.

\begin{definition}[Input simulation]
  A symbolic input $i$ simulates a concrete input $j$ denoted as $i\sim j$ in the following cases.\\
  $s\sim a$, where $s$ is a symbol and $a$ a concrete action.\\
  $i\sim j\implies \First i \sim \First j$\\
  $i\sim j\implies \Second i \sim \Second j$
\end{definition}

And $s\in i_s$ and $c\in i_c$ are defined as follows.

\begin{definition}[Symbol or Value from input]
  $c|s\in \First i = c|s\in i $\\
  $c|s\in \Second i = c|s\in i $\\
  $c|s\in a = a $
\end{definition}
