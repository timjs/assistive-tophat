% !TEX root=../main.tex

\section{Examples}
\label{sec:examples}

\subsection{Dining Computer Scientists Problem}

The dining philosophers problem is a classic concurrency problem in computer science.
A number of philosophers sit at a round table with a meal in front of them.
In between the plates lies one fork.
In order to eat their meal, each philosopher has to acquire two forks.
This, of course, means that all philosophers cannot eat at the same time, since there are not enough forks.
Deadlock can occur when all philosophers pick up the fork to their right (or left).
Then, everybody has one fork.
Therefore, each philosopher cannot start his meal, and is also not allowed to put his fork back on the table.

\lstset{emph={this, that, name, left, right}}
\begin{TASK}[
    float=ht,
    numbers=right,
    caption={Dining philosophers problem with three computer scientists.},
    label=lst:dining]
  let fork0 = ref True in $\label{lst:phil:fork0}$
  let fork1 = ref True in $\label{lst:phil:fork1}$
  let fork2 = ref True in $\label{lst:phil:fork2}$
  let pickup = \ this. \ that. $\label{lst:phil:this}$
    if !this $\label{lst:phil:deref}$
      then this := False >>? \ <<>>. $\label{lst:phil:mark-used}$
        if !that then this := True else fail $\label{lst:phil:that}$
      else fail in
  let scientist = \ name. \ left. \ right. $\label{lst:phil:scientist}$
    pickup left right <?> pickup right left in $\label{lst:phil:pick}$
  scientist "Alan Turing" fork0 fork1 <&> $\label{lst:phil:scientist0}$
  scientist "Grace Hopper" fork1 fork2 <&> $\label{lst:phil:scientist1}$
  scientist "Ada Lovelace" fork2 fork0 >>= \ _ . $\label{lst:phil:scientist2}$
    edit "Full bellies"
\end{TASK}

We look at dining computer scientists instead.
\cref{lst:dining} lists an implementation in \TOPHAT for this problem, with three computer scientists.
The forks are represented by references containing Booleans (\cref{lst:phil:fork0,lst:phil:fork1,lst:phil:fork2}).
The value $\True$ indicates that the fork is available,
$\False$ indicates that the fork is being used.

Picking up a fork is only possible when the fork is available,
i.e the reading the reference results is $\True$ (\cref{lst:phil:this}).
This fork is then marked as being used (\cref{lst:phil:mark-used}).
The use of references ensures that the neighbouring scientist cannot pick up this fork: this choice will be disabled.
After that, one can press continue if the second fork is also available (\cref{lst:phil:that}).
For the sake of simplicity, one returns the first fork, rather than setting the second fork to $\False$, and then setting both to $\True$ again.

Each computer scientist takes as arguments a name and references to the two forks that he or she can reach (\cref{lst:phil:scientist}).
They have a choice to take either the left or the right fork.
This is represented with an user choice ($\Xor$, \cref{lst:phil:pick}).
The last lines instantiate three computer scientists sitting next to each other (\cref{lst:phil:scientist0,lst:phil:scientist1,lst:phil:scientist2}).
In \TOP terms, this means they collaborate in parallel ($\And$) while eating their dinner while sharing some resources,
in this cease $\lbl{fork0}$, $\lbl{fork1}$, and $\lbl{fork2}$.

Note that the events of picking up a fork are performed sequentially.
That is, when one computer scientist decides to pick up his right fork, we will handle that event first.
After that, we will handle the choices from the other scientists.
So, the order of the events is explicitly determined by the scientists themselves.
% This is regardless of choices interfering or not.

\todo{Write analysis.}
In \cref{sec:todo} we will analyse this example.
Our goal is to hint each scientist which choice to make, in order to reach the common goal of full bellies.
When the scientists follow these hints, no deadlock will occur.


\subsection{Tax subsidy request}

The example program listed in this section is taken from our previous work on symbolic execution for \TOPHAT~\cite{Steenvoorden2019}.
It models a simplified tax subsidy application process for citizens who have installed solar panels.

A subsidy is only given under the following conditions.
\begin{itemize}
\item The roofing company has confirmed that they installed solar panels for the citizen.
\item The tax officer has approved the request.
\item The tax officer can only approve the request if the roofing company has confirmed, and the request is filed within one year of the invoice date.
\item The amount of the granted subsidy is maximal 600 EUR.
\end{itemize}

The listing below gives the \TOPHAT code for this example.

\lstset{emph={invoiceDate,today,confirmed,invoiceAmount,approved}}
\begin{TASK}[
    float=ht,
    numbers=right,
    caption={Subsidy request and approval workflow at the Dutch tax office.},
    label=lst:tax]
  let getCurrentDate = enter Date in
  let provideDocuments = enter Amount <&> enter Date in
  let companyConfirm = edit True <?> edit False in
  let officerApprove = \ invoiceDate. \ today. \ confirmed.
    edit False <?> if (today - invoiceDate < 365 /\ confirmed) $\label{lst:tax:officer-approve-def}$ then edit True else fail in
  getCurrentDate >>= \ today.$\label{lst:tax:citizen-info}$
  provideDocuments <&> companyConfirm >>= \ <<<<invoiceAmount, invoiceDate>>, confirmed>>. $\label{lst:tax:documents-and-company-confirm}$
  officerApprove invoiceDate today confirmed >>= \ approved.$\label{lst:tax:officer-approve}$
  let subsidyAmount = if approved then min 600 (invoiceAmount / 10) else 0 in
    edit <<subsidyAmount, approved, confirmed, invoiceDate, today>>$\label{lst:tax:result}$
\end{TASK}

In previous work, we have shown that this code indeed adheres to the requirements listed above.

Instead of assisting the developer, by proving the program correct, we would now like to support the end user that is requesting a subsidy.

The end user wants the outcome of this program to be a subsidy amount larger than zero.

Running the simulation function will result in the following set:

\begin{table}[ht]
  \centering
  \begin{tabular}{LLL}
    \toprule
    \text{Symbolic value} & \text{Symbolic input} & \text{Path condition} \\
    \midrule
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second \First, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second \First, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\Second \First, \First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\Second \First, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \Second s_{\id{i}}, \Second \First, \First \First s_{\id{a}}, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \First s_{\id{a}}, \Second \First, \First \Second s_{\id{i}}, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second \First, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second \First, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\Second \First, \First \First s_{\id{a}}, \First \Second s_{\id{i}}, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\Second \First, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \Second s_{\id{i}}, \Second \First, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \First s_{\id{a}}, \Second \First, \First \Second s_{\id{i}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\Second \Second,\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\Second, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \Second s_{\id{i}}, \Second, \First \First s_{\id{a}}, \First]  & \True \\
    \tuple{                        0,  \False,\False, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \First s_{\id{a}}, \Second, \First \Second s_{\id{i}}, \First]  & \True \\
    \bottomrule
  \end{tabular}
  \begin{tabular}{LLL}
    \toprule
    \text{Symbolic value} & \text{Symbolic input} & \text{Path condition} \\
    \midrule
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second \First, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second \First, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\Second \First, \First \First s_{\id{a}}, \First \Second s_{\id{i}}, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\Second \First, \First \Second s_{\id{i}}, \First \First s_{\id{a}}, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \Second s_{\id{i}}, \Second \First, \First \First s_{\id{a}}, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \tuple{\min\ 600\ (s_{\id{a}}/10),  \True, \True, s_{\id{i}}, s_{\id{t}}} & [s_{\id{t}},\First \First s_{\id{a}}, \Second \First, \First \Second s_{\id{i}}, \Second] & s_{\id{t}}-s_{\id{i}}<365 \\
    \bottomrule
  \end{tabular}
  \caption{}
  \label{}
\end{table}

As a goal we set that the subsidy amount should be larger than zero. This leaves us with the following cases.

From the end states we can conclude that invoiceAmount should be larger than zero in order for the result to be larger than zero. This results in an additional constraint.

In the end, we can use the above to give hints to the user.

First, a date must be entered. Then the user can choose to ender an amount larger than zero, a date that is within 365 from now, or a "RL".
etc.
